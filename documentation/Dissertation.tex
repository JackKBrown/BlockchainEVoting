\documentclass{entcs}
\usepackage{CSC8498macro}

\usepackage[backend=biber, style = numeric]{biblatex}
\addbibresource{blockchain.bib}

\usepackage{graphicx}

\begin{document}

\begin{frontmatter}

\title{Blockchain E-Voting}
\author{Jack Brown}
\address{School of Computing Science, Newcastle University, UK} 

\thanks{Email:
    \href{mailto:j.k.brown@newcastle.ac.uk} {\texttt{\normalshape
        j.k.brown@newcastle.ac.uk}}}

\begin{abstract} 
Demonstrating the practicality and efficacy of using Ethereum smart contracts to host and perform an electronic vote. We explore the technologies required to guarantee properties such as voter privacy whilst maintaining the benefits of using a blockchain for improved Verifiability and Integrity. We then describe a system built on an Ethereum blockchain and how it functions and performs finding advantages and disadvantages to any similar system.
\end{abstract}

\begin{keyword}
Blockchain, E-Voting, Smart Contracts, Ethereum, Solidity
\end{keyword}

\end{frontmatter}

\section{Introduction}
E-Voting for significant votes is a contentious issue due to the amount of trust required for any system facilitating these important votes. However the benefits of E-Voting can be numerous; potentially increasing the interest to vote by younger generations and individuals being unable to vote due to time constraints. In the UK individuals can vote by visiting the polling station they are registered at between 7am and 10pm \cite{pollStations}, traditionally these votes also take place on Thursdays, a working day. This can require an individual to put significant effort into reaching a poll station and due to work it could be infeasible to do so. E-Voting could be done over the internet, using any device an individual has increasing convenience and availability. A vote also does not need to be exclusively electronic meaning an adequate protocol can only serve to increase the peoples say in democracy. Beyond this is the benefits of speed and price to vote, E-Voting can be digitally counted for increased speed and accuracy without having to pay counters or administrators for polling stations. But still the risk of unforeseen errors or security flaws many view to far out way these conveniences brought about by E-Voting \cite{lauer2004risk}. We shall explore then in this paper how this implementation using smart contracts on the blockchain can help alleviate the potential downfalls of E-Voting.
%and the untrusted[use different word] nature of these technologies. blockchain has emerged as another potential solution to this problem though, in this report we shall discuss the application of blockchain to e-voting, their advantages and disadvantages, the differences between certain solutions, and conclude on the usefulness of this idea.

Voting is used worldwide to decide a range of issues, different schemes of voting exist but the underlying principle is the same. A group of parties wish to decide on an issue and whichever solution gets the most support should win. For this reason voting needs to be fair and obey the rules of the vote. You need to be able to give certain guarantees of this and in E-Voting this means a system must guarantee certain properties of a vote.

Blockchain was originally described in the Bitcoin white paper by Satoshi Nakamoto \cite{BTCWhitepaper}. In this paper a system for tracking ownership of a digital currency, Bitcoin, was invented. This system is what is commonly known today as the blockchain. The uses of blockchain extend beyond currency though due to the levels of integrity and the ability to be used as a vessel for mutual trust between distrusting parties due to total transparency. For these reasons this technology has seen use as supply chain management, international trade, and for E-Voting amongst other things \cite{wust2018need}. The reason E-Voting is an interesting application for blockchain technology is that a blockchain can be secure and completely public allowing voters to verify the election is being held honestly. This can be a great tool to improve a groups trust in a system that they may not fully believe in and to assure that a vote is correct. This public verifiability is desirable, which is why blockchain is being used instead of a centralised database. But this comes at the cost of a loss of privacy or eligibility. In order to demonstrate that an individual can vote or has not already voted they need to prove their identity through some means. Our problem is then to provide both privacy and eligibility whilst maintaining the benefits of the blockchain.

In this paper we will endeavor to explore how blockchain can used for E-Voting, particularly how to allow for voter anonymity and privacy on a public blockchain. We use ideas presented by other groups in particular a principle protocol that we will base our design off is that by Hardwick et. al. \cite{hardwick2018}. 

\subsection{Overview}

\begin{enumerate}
    \item Introduction, an initial discussion of the problem space and the subjects involved. As well as our Aims and Objectives.
    \item Background Material, here we cover the principles and content behind this project. Beyond this we explain how different issues can be address with different technologies.
    \item Design,
    \item Implementation,
    \item Evaluation and Testing, in this section we evaluate the design and discuss how it might fail and what we could improve about it.
    \item conclusions and further work, in this section we draw from the work we've done and how that impacts the field of voting as well as what could be done to extend this project in the future.
\end{enumerate}

\subsection{Aims and Objectives}
%could probably write something more here?
\begin{center}
    {\bf Aim}: To investigate and implement a blockchain E-Voting algorithm that implements methods to ensure Privacy, Verifiability, availability, transparency, and flexibility. 
\end{center}
{\bf Objectives}
\begin{itemize}
    \item Identify desirable properties of voting and metrics for evaluation.
    \item Design and Implement a basic application for voting
    \item Extend the application to include the desirable properties
    \item Evaluate and compare to other solutions.
\end{itemize}

\section{Background Material}
In this section we discuss the material studied and the nature of technologies and ideas used for this dissertation.

\subsection{Voting and E-Voting}
Solutions to voting problems that are brought forth by different E-Voting protocols are can be specific to that problem and can cause other difficulties, beyond this some properties are incompatible as discussed by Chevallier et. al. \cite{Chevallier-mames06onsome}. Other properties can even be undesirable in different voting scenarios, for example it is necessary to ensure that voter privacy doesn't exist in the UK House of Commons so members of Parliament are accountable to their constituency for how they vote. This makes it difficult to evaluate an objective measure of what is good or bad with a protocol. This is why we must identify and define the properties that we desire in our protocol, that an election may have.

%http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.852
%on the incompatible properties of voting schemes 2006
There are many different voting properties we can describe we shall use the definition provided by Wang et al. \cite{RequirementOfEVoting} in their paper requirements of E-Voting. We use these definitions as they're well described and used by other protocols wishing to define their solutions making them ubiquitous across this field.
%https://pdfs.semanticscholar.org/e734/d63888d81075efa0402599ae4e43772cf2e7.pdf
\begin{itemize}
  \item {\bfseries Correctness}, votes should all be counted and all counted votes need to be valid. Note, this allows that invalid votes be cast just that they are not counted.
  \item {\bfseries Privacy}, the identity of a voter, as long as that voter does not reveal it, should not be known to others.
  \item {\bfseries Anonymity}, whether a voter is known to have cast a vote. The privacy property only guarantees that a voter's choice should not be known not whether they voted or not.
  \item {\bfseries Fairness}, the votes cast so far should not be countable until all votes are cast or the allotted voting period has ended.
  \item {\bfseries Unreusability}, no voter should be able to cast two ballots that are both counted in the end count.
  \item {\bfseries Eligibility}, only those with authorisation should be able to vote.
  \item {\bfseries Robustness}, whether and by what degree a protocol is tolerant to malicious intent and system fault.
  \item {\bfseries Verifiability}, who can verify the vote.
  \item {\bfseries Universally Verifiable}, anyone can verify the final result. 
  \item {\bfseries E2E-Verifiable}, is it possible to verify ones ballot has been cast and counted.
  \item {\bfseries Usability}, how easy is it to take part in the protocol.
\end{itemize}

Using blockchains we hope to achieve a greater level of Verifiability and Privacy. To achieve our aim we must then ensure Correctness, Privacy, Unreusability, and Eligibility whilst maintaining the verifiability, universal verifiability, and E2E-Verifiability that can be granted by public blockchains. Beyond this we will also try to achieve Fairness, Usability and Anonymity.

%feels like an abrupt end here maybe something else needs to be added.

\subsection{Blockchain}
A blockchain is a list of transactions grouped into blocks, these blocks are connected in a chain like a linked list \cite{blockchainBeginners} using cryptography. We define a transaction as any event written to the blockchain. A blockchain is then in essence a distributed ledger, a list of transactions that can be read and written to by a group of individuals. It is the properties granted by the structure of the blockchain that make it notable and warrants the merit it has received in the time since its creation by Nakamoto \cite{BTCWhitepaper}. Specifically blockchain grant improved security properties in particular integrity. Anything written on a blockchain as long as the design is appropriate and enough time has passed should not be able to be removed. If a change is made it is detectable by all those that can read the blockchain. Below in figure \ref{fig:BlockCon} we can see an example of the Bitcoin block construction.

%https://commons.wikimedia.org/wiki/File:Bitcoin_Block_Data.svg
%
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.45]{s_BitcoinBC.png}
    \caption{Example blockchain construction}
    \label{fig:BlockCon}
\end{figure}

\subsubsection{Hashing}
In order to link the Blocks together each block contains a hash, a cryptographic pseudo random reference that will change completely if the input is altered. A hash works as a one way function, \(h(m)\), that takes input of varying length and produced a fixed output that, in a strong hash, should be irreproducible except for that input. Three properties \cite{cryptoHandbook} define a strong hash:

\begin{enumerate}
    \item Preimage resistance, given the resulting hash of \(h(m)\) it should be infeasible to find \(m\) from that hash. 
    \item 2nd-preimage resistance, given \(m_1\) it is infeasable to find \(m_2\) such that \(h(m_1) = h(m_2)\).
    \item collision resistance, it is computationally infeasible to find any two inputs such that \(h(m_1) = h(m_2)\)
\end{enumerate}

These properties as can be seen, if they're guaranteed, provide immutability to the blockchain. This is because a change to any transaction on a block will change the hash of the following block as can be seen in figure \ref{fig:BlockCon} which in turn will change the next. A chain reaction will occur along the entire blockchain making the change detectable and in some cases where proof of work must be provided a blockchain, as will be discussed in section \ref{sec: consensus}, is computationally impossible to change.

\subsubsection{Types of Blockchain}
How a blockchain is designed will change properties of the blockchain such as its privacy, security, and trust. The first design choice in respect to E-Voting is whether a blockchain is permissionless or permissioned \cite{wust2018need}, in other works this is sometimes referred to as being public (permissionless) or private (permissioned) \cite{blockchainBeginners}. These definitions refer to the read and write permissions on a blockchain. 

Permissionless blockchains are completely public, anyone can add their computer to the network, become a validator, add transactions to the blockchain, or download and read the blockchain. Bitcoin is an example of a permissionless blockchain.

Permissioned blockchains restrict who can be a validator, they may also restrict who can add transactions to a blockchain and who can read the blockchain. 

The desire to make a blockchain permissioned can come from a few sources such as economic or privacy concerns. Permissioned blockchains come at the cost of being more centralised which means trust must be placed in some entity either the validators or an authority who delegate trust to the validators. This trust in turn is what allows the validators on a permissioned blockchain to use different types of consensus which can be faster, more economical, and environmental than others as discussed in section \ref{sec: consensus}.

This question of not needing trust \cite{lemieux2016trusting} is often raised as a positive for decentralised permissionless blockchains like bitcoin where the ability to place trust solely in the maths and code behind the algorithm is useful and this transfers across to E-Voting where the authority in charge of organising the vote might be untrusted by the voters.

Either of these two types of blockchain could work with the requirements set, to preserve the verifiability properties for the contents of the votes, we must ensure the ability to read the blockchain is available to all participants of the election but care must be taken when using a private blockchain depending on how addresses are allocated on the blockchain this could make the Privacy and Anonymity assurances redundant if it is possible to link an address to a voter.

\subsubsection{Consensus and Block Construction} \label{sec: consensus}
%Not too sure how much I really need to cover that I've talked about here its definitely important but not sure if this is too much off the track.Probably worth mentioning a little bit and more in a bullet pointed fashion to just note that depending on the flavour used will really affect the integrity and certainty of that integrity though the algorithm itself will not change just the trust you can have in its integrity.

When building a blockchain validators add transactions by appending them to the end of the current block. After a period of time that block is concluded by calculating and appending its hash. A new block is started with the previous block's hash to form the chain of blocks. Along with additional implementation dependant metadata such as time of creation. The hash provides the method of proving integrity, as discussed if one block is changed all the following block hashes will change meaning each one must be recalculated. The method of determining which party writes a block is called a consensus protocol. 
Proof of Work\cite{BTCWhitepaper} is one such protocol, typically used on permissionless systems it requires doing something computationally hard like finding a SHA256 hash starting with a sequence of zeros, this is the method used by Bitcoin. The problem with this is that it's computationally expensive, the cost of running these networks can be gargantuan. According to an evaluation on the website digiconomist \cite{BTCenergy} the Bitcoin network annually uses an estimated 49.39 TeraWatt hours of electricity this is roughly equivalent to the usage of Singapore. Beyond this it relies on the assumption the majority of computational power will represent an honest group of parties, this is commonly referred to as a 51\% attack\cite{BTCWhitepaper}\cite{baliga2017understanding}. In smaller blockchains this isn't as reliable as it is easier for a larger party to make up a majority. 

Other consensus schemes rely on being able to trust the validators to be honest, two such methods are proof of stake and proof of authority\cite{blockchainBeginners}\cite{baliga2017understanding}: where a party shows that they will take a loss if they are dishonest thus allowing them to participate in the consensus. In proof of authority a party has control over the blockchain for example in a permissioned blockchain where validators must sign the blockchain with a private key belonging to the owner to make the block valid. These solutions do mitigate the problems of proof of work but require trust in the authority or the magnitude of the stake being a worthy incentive.

\subsubsection{Smart Contracts}
Smart contracts enable users to execute code on the blockchain, some blockchains use smart contracts as major selling point for its services such as Ethereum \cite{wood2014ethereum} and Hyperledger Burrow \cite{HyperLedgerBurrow} where users can execute arbitrary code. When designing a blockchain for E-Voting we can add specific smart contracts for that purpose. The ability to execute code on a blockchain can allow a wide array of E-Voting algorithms to be ran on the blockchain itself. Though some E-Voting algorithms do exist without smart contract capabilities such as the protocol designed by Zhou and Chan for voting using Bitcoin \cite{zhao2015vote}. But protocols such as this are limited by the strict nature of the Bitcoin platform and the inability to perform certain actions available to platforms like Ethereum.

Code executed on a blockchain is stored in a special smart contract layer as a transaction. Where it can be executed by validators to add more transactions or executed by parties reading it if the code does not require any state change.

\subsubsection{Ethereum}
%don't like reward
Ethereum is a blockchain specifically designed for smart contracts by Wood in 2014 \cite{wood2014ethereum}. It can run code through transactions which is ran by validators of the blockchain. Code difficulty to run is measure in 'gas' which users can set a transaction value which uses the Ethereum cryptocurrency 'ether'. This results in a system where you can pay to run code on a public blockchain effectively hiring the computer resources of the validators to run code as part of the transaction.

%could maybe include more here on gas and ether prices etc 

\subsection{Blind Signatures}
Blind signatures in cryptography as described by Chaum \cite{chaum1983blind}, are methods of providing a cryptographic signature to a client without learning the content the authority has signed. This can be used to help protect the privacy of an individual. This can be achieved with RSA keys with the following algorithm \cite{MITcrypto}.
\(m, s, r, e, d, N\) These characters represent the message, signed message, random coprime of N, public RSA exponent, private RSA exponent, and RSA modulus N.
\begin{itemize}
    \item client sends blinded message using random blinding factor and public key: \\
    \(m_b = m.r^e (mod N)\)
    \item authority signs the blinded message using private key: \\
    \(s_b = m^d_b = m^d.r^ed = m^d.r (mod N)\)
    \item client unblinds the signed message using the modular inverse of \(r, r^{-1}\): \\
    \(s = s^e_b.r^{-1} = m^d.r.r^{-1} = m^d (mod N)\)
\end{itemize}

\subsection{Technologies for Implementation}
%subsection name work in progress
In this section we look at different languages and technologies to use for implementing a distributed application. Choosing which ones ones are preferable for our system.


\subsubsection{Solidity}
Solidity is a language designed specifically for use on the Ethereum blockchain, because of this it has strict rules that help develop more concise more efficient code for blockchains to help reduce transaction costs. One disadvantage of Solidity though is how quickly the language changes due to it being in early development with the release of version 0.5.x in 2019 it broke a lot of pre-existing code due to big changes in syntax rules and functions being removed from the language.

\subsubsection{Node.js and JavaScript}
Providing a way of running the back-end of the server using JavaScript. Key benefits of using Node is how easy it is to make applications portable which is an issue when having to built a tool using several different platforms. With the node package manager, npm, you can easily install many libraries and track which ones are necessary for your application. The wide selection of libraries include those specifically made for blockchain applications such as Web3 and Truffle.
JavaScript is also the most universal language for client side scripting which makes it an obvious choice for use. JavaScript also has built in Asynchronous calls ideal for blockchain calls using libraries such as web3 or the truffle frameworks own JavaScript libraries. 

\subsection{Truffle Framework}
An implementation of a Solidity compiler for Ethereum. Available on Node.js Truffle \cite{truffle} is a framework that covers both the deployment of solidity to a blockchain and communicating with the blockchain using its own web3 libraries with JavaScript. Advantages

%This was an obvious choice for me as it included a lot of the packages and tools I needed together and ready working with decent documentation but need to show also why this was greater than the alternatives
\subsection{Java}
%https://github.com/ethereum/ethereumj
The EthereumJ project is an implementation of the Ethereum yellow paper of java. It is fully compatible with maven to deploy the project as a web application. Advantages of using this system is the ability to utilize the many libraries in java which all work perfectly cross platform due to the Java Virtual Machine. The difficulty of this is that this would also require considerable amounts of a client side scripting language such as JavaScript too to implement parts of the protocol with more sensitive content. 

\subsubsection{Others}
\begin{itemize}
    \item Python is an object oriented language with wide applications due to its selection of available libraries. There is a lot of Support for Python based Ethereum smart contracts such as web3.py and py-evm but many of these projects are still in early development with many reported bugs making it sub-optimal for a stable code development.
    \item PHP is a commonly used language for server side scripting in web development. Though originally designed for web development, due to a lack of asynchronous support it makes development of blockchain applications using PHP difficult.
\end{itemize}

\subsubsection{Conclusion}
For the smart contract we used the Truffle framework this was preferable for the built in support for its own testRPC Ganache allowing for faster development. Beyond this it includes its own javascript libraries based off Web3.0 for interacting with contracts.

\section{Design} \label{sec: Design}
%can split this into design and implementation.
In this section we design the protocol and application for this project, we will also discuss security details for both the smart contract and web application and how these will affect our design. This design involves two key parts the deployment of a smart contract and of a web application to organise the election and interact with the smart contract.

\subsection{High-level Protocol} 
This protocol uses an Ethereum blockchain to allow for public verifiability and blind signatures to protect the privacy of its voters from the election authority as well as ensure voter eligibility as described by Hardwick et. al. \cite{hardwick2018}. The protocol is described here in 3 phases
%As stated we are using ideas described by Hardwick et. al. \cite{hardwick2018} in our implementation, to summarise our version of their protocol briefly we have split it into 4 phases:
\begin{enumerate}
    \item \textbf{Initialisation Phase}. During this phase a new contract is initialised by the election authority. The authority adds the list of candidates as well as a start and end time. Importantly the authority includes the public key of the authorities RSA key pair. which allows verification of signed tokens.
    \item \textbf{Preparation Phase}. At this point voters can begin to authenticate with the authority and get signed tokens. This can be done using the web application through a blind signature scheme, the blinded message is constructed client side and sent to be signed on the server then returned.
    \item \textbf{Voting and Counting Phase}. Everyone with a valid signed token can vote at this point. To do this they construct a ballot and broadcast it to the blockchain. Ballots can be cast between the allotted times as dictated at creation. Votes can be counted at any point after the start time.
\end{enumerate}

\subsection{Security design and recommendations}
%this could be split into parts 
One intention of this project was to demonstrate that privacy can be assured on a blockchain where many can read the information, as stated this privacy is meaningless unless efforts of made to protect the voters privacy across the entire voting procedure. In this section we briefly consider some potential security flaws that could undermine the project and discuss efforts made or what could be done to mitigate them with a risk analysis. We will use the STRIDE model \cite{STRIDE} for defining attacks on the system and a risk model comparing likelihood and impact on a scale of one to five.

\subsubsection{Voter privacy}
\textbf{Attack} - Theft of user data or ballot through ip/packet sniffing \cite{ansari2002packet} combined with blockchain analysis. By inspecting the packets or ip addresses sent to the web application you could discover user data and even make educated guesses on the ip of a voter by comparing when ballots are submitted to when voting requests are made. \\
\textbf{Threat} - Spoofing, and Information Disclosure. \\
\textbf{Risk} - likelihood is reasonable 3/5, it requires technical proficiency but is hard to detect. Impact is high 4/5 depending on how much information is leaked but it could undermine the entire purpose of this application.\\
\textbf{Design choices and solutions}
\begin{itemize}
    \item HTTPS, this is an easy solution to packet sniffing and should be implemented when deploying the web application.
    \item Permissioned blockchain, this is a potential method of reducing who could compare the blockchain data to ip calls. But this is a poor solution as it only prevent those without read permissions from performing this attack, those with permission who are likely to be the ones with the most interest in discovering this information can still perform the attack.
    \item Use of a VPN or tor network, this will protect from identification on the server side and client side. There are ways of circumventing these defences but they act as another protective layer from attacks.
\end{itemize}

\subsubsection{SQL Injection}
\textbf{Attack} - SQL Injection when authorising users, this could lead to unlimited tokens being available and querying the database for private information of voters. \\
\textbf{Threat} - Elevation of privileges, and potential Information Disclosure \\
\textbf{Risk} - likelihood is high 4/5, SQL Injection is commonly known exploit. Impact is high 4/5, this could break the election and be a violation of laws protecting individuals data such as the GDPR.\\
\textbf{Design choices and solutions}
\begin{itemize}
    \item sanitize SQL inputs, the Node.js SQL library has functions that will escape all special character when querying the database. These are used to ensure security against Injection.
\end{itemize}

\subsubsection{Blind signature attack}
\textbf{Attack} - \\
\textbf{Threat} - \\
\textbf{Risk} - likelihood is \\
\textbf{Design choices and solutions}\\
\begin{itemize}
    \item 
\end{itemize}

\subsubsection{attack}
\textbf{Attack} - \\
\textbf{Threat} - \\
\textbf{Risk} - likelihood is \\
\textbf{Design choices and solutions}\\
\begin{itemize}
    \item 
\end{itemize}

%walk through the design process and the decisions made and the security impacts of them.
%As Matt suggested should talk here also about evaluation of threats and how they're addressed. 
%Stride assessment could work as well as looking at risk as a calculation of likelihood vs consequence this draws in common ideas shown in previous modules and can help draw a clear logical connection in the security assessment


\section{Implementation}
In this section we discuss how the design was implemented.

\subsection{Creating an Election}
%find out if you can include an appendix

%NOTE remember if I get time I want to dynamically create the rsa keys for each election rather than using a pre-generated one this is more secure and a constructor param would be the modulus  so this paragraph here would have to change.
To create an election the party must initialise the smart contract creating a new instance on the Ethereum blockchain. When initialising the contract, we have 2 inputs the start time and end time. These parameters are used to dictate when certain functions are allowed to be called by comparing it to the blockchain timestamp. These parameters are all stored in this instance of the smart contract.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_constructor.png}
    \caption{Constructor prototype}
    \label{fig:constructor}
\end{figure}


One issue encountered when designing this stage of the protocol is that solidity doesn't yet support nested arrays, so you cannot pass the candidates list as a parameter as can be seen from the prototype in figure \ref{fig:constructor}. This was easily circumvented by creating an add candidate function, this also adds more flexibility to the smart contract allowing to add potentially late entering candidates after the contract is instantiated. 

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_addCand.png}
    \caption{Add candidate prototype}
    \label{fig:addCand}
\end{figure}

The web application interfaces with the smart contract on the create page where we allow for creation of a new instance or to look up an existing instance using the contract memory address. When created or by looking a contract up you can view current candidates list and call the add candidates function providing you meet the requirements of calling it. Those being that the function is called by the instance creator, and that it is called before the start-time.

After creating the contract the web application also displays the instance address as can be seen figure \ref{fig:create_loaded}, this is important for none technical users that might not know how to extract this information from transaction history and are relying on the web application. The instance creator can then distribute this address to the voters.

%might want to reduce this to scale 0.5?
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_create_loaded.png}
    \caption{Web application viewing loaded contract on create page}
    \label{fig:create_loaded}
\end{figure}

%when talking about signing hardwick et al say they use the blockchain public key I didnt do that due to the signing issue of sending an arbitrary message to be signed by the CA that they cannot detect due to it being blinded this is circumvented by using RSA

\subsection{Authorisation}\label{sec: Auth}
Preparation is the process of authenticating to the authority running the vote, the process of authenticating is solely done in the web application. This is to protect the identity of the voters, the authority needs to use a centralised database or some equivalent private form of data storage. For our implementation we used an SQL database where the voter could authenticate using a username and password, though the process of authentication is application dependant. The factor most important in this phase is the use blind signatures to produce a signed message or 'token' that the voter can use to prove they are authorised to vote without revealing their identity to anyone when they vote including the authority who only knows the voter has a valid token not which voter has which token. The message we used was the voters Ethereum address as this could be verified on the blockchain by looking at the transaction origin.

When validating the signature all the smart contract needs to check is the message, the senders address should be equivalent to the message.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.45]{ss_verifyToken.png}
    \caption{Verify token prototype}
    \label{fig:verifyToken}
\end{figure}

The security of this method of assuring total privacy has caveats though, it is only a strong method if there is no way to circumvent the system. This could be either through recognising the address of the voter or through monitoring packets and ip addresses sent to the website. We must also assure then that appropriate steps are taken.
This method should still assure eligibility though even if privacy and anonymity are compromised due to external factors.

\subsection{voting and counting}
Voting is done on the web application by loading the correct memory address for the desired contract instance, in a real world application this would be given when told about the vote. After loading the contract the voter must select a candidate and provide a valid token as seen in figure \ref{fig:vote_loaded}, using JavaScript this is then sent as a contract call. As can be seen in figure \ref{fig:castBallot} the castBallot function takes these inputs and constructs a ballot to be appended to the ballot list. The token is verified as discussed in section \ref{sec: Auth}. 
Beyond assuring authorisation voting should also be limited to a period of time so a final result can be decided upon, for this we can require that voting only occurs within the predefined period of the start of the election and the end of the election.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_castBallot.png}
    \caption{Verify token prototype}
    \label{fig:castBallot}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_voteLoaded.png}
    \caption{Web application viewing loaded contract on vote page}
    \label{fig:vote_loaded}
\end{figure}

Finally the smart contract provides a function to count the votes figure \ref{fig:count} for each candidate, this is achievable without using a function but this allows for easier access. The web application interfaces with this function on the results page where you can load and view the results of any contract by the contract instance address.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_count.png}
    \caption{Count prototype}
    \label{fig:count}
\end{figure}


\section{Results and Testing}

\subsection{Cost}
Ethereum smart contract transactions that change the state of the blockchain have an associated cost to them, measured in gas. This is a measurement of how difficult it is to run these transactions for the validators, if this smart contract was ran on a public Ethereum blockchain this would also be a measure of cost in ether.

\subsection{White-box Testing}
Tests for the smart contract were written using Mocha \cite{mocha}. Mocha runs tests serially with an assert style testing mechanism, for which we are using Chai \cite{chai}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.8]{ss_testResults.png}
    \caption{Tests ran}
    \label{fig:testResults}
\end{figure}


%show the gas pricing of each transaction
%discuss the unit tests performed on the smart contracts
%maybe latency would be a good idea


\section{Evaluation}\label{sec: Eval}
This system allows voters to register and vote on the same day, in some elections such as a general election voters must register weeks in advance or lose the opportunity to vote.

votes may be private but you can prove your votes nature by just sharing the private key this undermines the coercion resistance built into hardwick et al alg as well as allows a lot of 'dodgy' practices

with a blind signiture you can't prove that you're not lying about losing a token. therefor if you lose a token you just can't vote in this system.

\section{Conclusions and further work}
This method of E-Voting demonstrates interesting solutions to potential problems posed by public voting. It is difficult to say whether this is preferable to existing physical or digital system, it is simply different. The difficulties posed by this protocol as discussed in section \ref{sec:eval} make it unforgiving to voters that make mistakes in the protocol leaving it unsuitable for large scale elections. Alternatives do exist to circumvent this having signed tokens assigned for each voter but this would forgo the privacy granted by blind signing. 

In the future I would like to try add more features to this system to provide more voting properties such as voter fairness. Another improvement I think could be made is trying to integrate Elliptic curve cryptography (ECC) instead of RSA, many blockchains are built using ECC, for address and signing. Ethereum uses the Elliptic Curve Digital Signature Algorithm (ECDSA) because of the reduced key sizes required for the algorithm. This would be an interesting area for further investigation, built in support and smaller keys could make for cheaper transaction costs and more manageable key sizes for users.
\printbibliography

\end{document}
