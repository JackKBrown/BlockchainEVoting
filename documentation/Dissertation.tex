\documentclass{entcs}
\usepackage{CSC8498macro}

\usepackage[backend=biber, style = numeric]{biblatex}
\addbibresource{blockchain.bib}

\usepackage{graphicx}

\begin{document}

\begin{frontmatter}

\title{Blockchain E-Voting}
\author{Jack Brown}
\address{School of Computing Science, Newcastle University, UK} 

\thanks{Email:
    \href{mailto:j.k.brown@newcastle.ac.uk} {\texttt{\normalshape
        j.k.brown@newcastle.ac.uk}}}

\begin{abstract} 
Demonstrating the practicality and efficacy of using Ethereum smart contracts to host and perform an electronic vote. We explore the technologies and protocols required to guarantee properties including voter privacy, Anonymity, and Eligibility whilst maintaining the benefits of using a blockchain for improved Verifiability and Integrity. We then describe and build a system built on an Ethereum blockchain evaluating it on the predefined objectives. Discussing its use cases and where it serves to improve on currently available solutions.
\end{abstract}

\begin{keyword}
Blockchain, E-Voting, Smart Contracts, Ethereum, Solidity
\end{keyword}

\end{frontmatter}

\section{Introduction}
E-Voting for significant votes is a contentious issue due to the amount of trust required for any system facilitating these important votes. However the benefits of E-Voting can be numerous; potentially increasing the interest to vote by younger generations and allowing individuals that might be unable to vote due to time constraints to participate. In the UK individuals can vote by visiting the polling station they are registered at between 7am and 10pm \cite{pollStations}, traditionally these votes also take place on Thursdays, a working day. This can require an individual to put significant effort into reaching a poll station and due to work, it could be infeasible to do so. E-Voting could be done over the internet, using any device an individual has increasing convenience and availability. A vote also does not need to be exclusively electronic meaning an adequate protocol can only serve to increase the electorate's say in an election. Beyond this is the benefits of speed and price to vote, E-Voting can be digitally counted for increased speed and accuracy without having to pay counters or administrators for polling stations. But still, the risk of unforeseen errors or security flaws many view to far out weigh these conveniences brought about by E-Voting \cite{lauer2004risk}. We shall explore then in this project how this implementation using smart contracts on the blockchain can help alleviate the potential downfalls of E-Voting.
%and the untrusted[use different word] nature of these technologies. blockchain has emerged as another potential solution to this problem though, in this report we shall discuss the application of blockchain to e-voting, their advantages and disadvantages, the differences between certain solutions, and conclude on the usefulness of this idea.

Voting is used worldwide to decide a range of issues, different schemes of voting exist but the underlying principle is the same. A group of parties wish to decide on an issue and whichever solution gets the most support should win. For this reason voting needs to be fair and obey the rules of the vote. You need to be able to give certain guarantees of this and in E-Voting this means a system must guarantee certain properties of a vote. We shall discuss these properties in section \ref{sec:voting}.

Blockchain was originally described in the Bitcoin white paper by Satoshi Nakamoto \cite{BTCWhitepaper}. In this paper a system for tracking ownership of digital currency, Bitcoin, was invented. This system is what is commonly known today as the blockchain. The uses of a blockchain extend beyond currency though due to the increased levels of integrity it allows and the ability to be used as a vessel for mutual trust between distrusting parties due to total transparency. For these reasons this technology has seen a use for supply chain management, international trade, and for E-Voting amongst other things \cite{wust2018need}. The reason E-Voting is an interesting application for blockchain technology is that a blockchain can be secure and completely public allowing voters to verify the election is being held honestly. This can be a great tool to improve a groups trust in a system that they may not fully believe in and to assure that a vote is correct. This public verifiability is desirable, which is why blockchain is being used instead of a centralised database. But this comes at the cost of a loss of privacy or eligibility. In order to demonstrate that an individual can vote or has not already voted they need to prove their identity through some means. Our problem is then to provide both privacy and eligibility whilst maintaining the benefits of the blockchain.

In this project, we will endeavor to explore how blockchain can be used for E-Voting. Particularly how to allow for voter anonymity and privacy on a public blockchain. We use ideas presented by other groups in particular a principle protocol that we will base our design off is that by Hardwick et. al. \cite{hardwick2018}. 

\subsection{Overview}

\begin{enumerate}
    \item Introduction, an initial discussion of the problem space and the subjects involved. As well as our Aims and Objectives.
    \item Background Material, here we cover the principles and content behind this project. Beyond this we explain how different issues can be addressed with different technologies.
    \item Design, an abstract description of our system and the purpose behind certain technologies used as well as analysis of potential security flaws and how they will affect the implementation and design.
    \item Implementation, review how the application was built and what was built.
    \item Evaluation and Testing, in this section we evaluate the application and discuss how it might fail and what we could improve about it. Beyond this we examine testing done to show the application works.
    \item conclusions and further work, in this section we draw from the work we've done and how that impacts the field of voting as well as what could be done to extend this project in the future.
\end{enumerate}

\subsection{Aims and Objectives}
%could probably write something more here?
\begin{center}
    {\bf Aim}: To investigate and implement a blockchain E-Voting algorithm that implements methods to ensure Privacy, Verifiability, availability, transparency, and flexibility. 
\end{center}
{\bf Objectives}
\begin{itemize}
    \item Identify desirable properties of voting and metrics for evaluation.
    \item Design and Implement a basic application for voting
    \item Extend the application to include the desirable properties
    \item Evaluate and compare to other solutions.
\end{itemize}


\section{Background Material}
In this section we discuss the material studied and the nature of technologies and ideas used for this project.

\subsection{Voting and E-Voting} \label{sec:voting}
Solutions to voting problems that are brought forth by different E-Voting protocols are can be specific to that problem and can cause other difficulties, beyond this some properties are incompatible as discussed by Chevallier et. al. \cite{Chevallier-mames06onsome}. Other properties can even be undesirable in different voting scenarios, for example it is necessary to ensure that voter privacy doesn't exist in the UK House of Commons so members of Parliament are accountable to their constituency for how they vote. This makes it difficult to evaluate an objective measure of what is good or bad with a protocol. This is why we must identify and define the properties that we desire in our protocol, that an election may have.

%http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.852
%on the incompatible properties of voting schemes 2006
There are many different voting properties we can describe we shall use the definition provided by Wang et al. \cite{RequirementOfEVoting} in their paper requirements of E-Voting. We use these definitions as they're well described and used by other protocols wishing to define their solutions making them ubiquitous across this field.
%https://pdfs.semanticscholar.org/e734/d63888d81075efa0402599ae4e43772cf2e7.pdf
\begin{itemize}
  \item {\bfseries Correctness}, votes should all be counted and all counted votes need to be valid. Note, this allows that invalid votes be cast just that they are not counted.
  \item {\bfseries Privacy}, the identity of a voter, as long as that voter does not reveal it, should not be known to others.
  \item {\bfseries Anonymity}, whether a voter is known to have cast a vote. The privacy property only guarantees that a voter's choice should not be known not whether they voted or not.
  \item {\bfseries Fairness}, the votes cast so far should not be countable until all votes are cast or the allotted voting period has ended.
  \item {\bfseries Unreusability}, no voter should be able to cast two ballots that are both counted in the end count.
  \item {\bfseries Eligibility}, only those with authorisation should be able to vote.
  \item {\bfseries Robustness}, whether and by what degree a protocol is tolerant to malicious intent and system fault.
  \item {\bfseries Verifiability}, who can verify the vote.
  \item {\bfseries Universally Verifiable}, anyone can verify the final result. 
  \item {\bfseries E2E-Verifiable}, is it possible to verify one's ballot has been cast and counted.
  \item {\bfseries Usability}, how easy is it to take part in the protocol.
\end{itemize}

Using blockchains we hope to achieve a greater level of Verifiability and Privacy. To achieve our aim we must then ensure Correctness, Privacy, Unreusability, and Eligibility whilst maintaining the verifiability, universal verifiability, and E2E-Verifiability that can be granted by public blockchains. Beyond this we will also try to achieve Fairness, Usability and Anonymity.

%feels like an abrupt end here maybe something else needs to be added.

\subsection{Blockchain}
A blockchain is a list of transactions grouped into blocks, these blocks are connected in a chain like a linked list \cite{blockchainBeginners} using cryptography. We define a transaction as any event written to the blockchain. A blockchain is then in essence a distributed ledger, a list of transactions that can be read and written to by a group of individuals. It is the properties granted by the structure of the blockchain that make it notable and warrants the merit it has received in the time since its creation by Nakamoto \cite{BTCWhitepaper}. Specifically blockchain grant improved security properties in particular integrity. Anything written on a blockchain as long as the design is appropriate and enough time has passed should not be able to be removed. If a change is made it is detectable by all those that can read the blockchain. Below in figure \ref{fig:BlockCon} we can see an example of the Bitcoin block construction.

%https://commons.wikimedia.org/wiki/File:Bitcoin_Block_Data.svg
%
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.45]{s_BitcoinBC.png}
    \caption{Example blockchain construction}
    \label{fig:BlockCon}
\end{figure}

\subsubsection{Hashing}
In order to link the Blocks together each block contains a hash, a cryptographic pseudorandom reference that will change completely if the input is altered. A hash works as a one-way function, \(h(m)\), that takes input of varying length and produced a fixed output that, in a strong hash, should be irreproducible except for that input. Three properties \cite{cryptoHandbook} define a strong hash:

\begin{enumerate}
    \item Preimage resistance, given the resulting hash of \(h(m)\) it should be infeasible to find \(m\) from that hash. 
    \item 2nd-preimage resistance, given \(m_1\) it is infeasible to find \(m_2\) such that \(h(m_1) = h(m_2)\).
    \item collision resistance, it is computationally infeasible to find any two inputs such that \(h(m_1) = h(m_2)\)
\end{enumerate}

These properties as can be seen, if they're guaranteed, provide immutability to the blockchain. This is because a change to any transaction on a block will change the hash of the following block as can be seen in figure \ref{fig:BlockCon} which in turn will change the next. A chain reaction will occur along the entire blockchain making the change detectable and in some cases where proof of work must be provided a blockchain, as will be discussed in section \ref{sec: consensus}, is computationally impossible to change.

\subsubsection{Types of Blockchain}
How a blockchain is designed will change properties of the blockchain such as its privacy, security, and trust. The first design choice in respect to E-Voting is whether a blockchain is permissionless or permissioned \cite{wust2018need}, in other works this is sometimes referred to as being public (permissionless) or private (permissioned) \cite{blockchainBeginners}. These definitions refer to the read and write permissions on a blockchain. 

Permissionless blockchains are completely public, anyone can add their computer to the network, become a validator, add transactions to the blockchain, or download and read the blockchain. Bitcoin is an example of a permissionless blockchain.

Permissioned blockchains restrict who can be a validator, they may also restrict who can add transactions to a blockchain and who can read the blockchain. 

The desire to make a blockchain permissioned can come from a few sources such as economic or privacy concerns. Permissioned blockchains come at the cost of being more centralised which means trust must be placed in some entity either the validators or an authority who delegate trust to the validators. This trust in turn is what allows the validators on a permissioned blockchain to use different types of consensus which can be faster, more economical, and environmental than others as discussed in section \ref{sec: consensus}.

This question of not needing trust \cite{lemieux2016trusting} is often raised as a positive for decentralised permissionless blockchains like bitcoin where the ability to place trust solely in the maths and code behind the algorithm is useful and this transfers across to E-Voting where the authority in charge of organising the vote might be untrusted by the voters.

Either of these two types of blockchain could work with the requirements set, to preserve the verifiability properties for the contents of the votes, we must ensure the ability to read the blockchain is available to all participants of the election but care must be taken when using a private blockchain depending on how addresses are allocated on the blockchain this could make the Privacy and Anonymity assurances redundant if it is possible to link an address to a voter.

\subsubsection{Consensus and Block Construction} \label{sec: consensus}
%Not too sure how much I really need to cover that I've talked about here its definitely important but not sure if this is too much off the track.Probably worth mentioning a little bit and more in a bullet pointed fashion to just note that depending on the flavour used will really affect the integrity and certainty of that integrity though the algorithm itself will not change just the trust you can have in its integrity.

When building a blockchain, validators add transactions by appending them to the end of the current block. After a period of time that block is concluded by calculating and appending its hash. A new block is started with the previous block's hash to form the chain of blocks. Along with additional implementation dependant metadata such as time of creation. The hash provides the method of proving integrity, as discussed if one block is changed all the following block hashes will change meaning each one must be recalculated. The method of determining which party writes a block is called a consensus protocol. 
Proof of Work\cite{BTCWhitepaper} is one such protocol, typically used on permissionless systems it requires doing something computationally hard like finding a SHA256 hash starting with a sequence of zeros, this is the method used by Bitcoin. The problem with this is that it's computationally expensive, the cost of running these networks can be gargantuan. According to an evaluation on the website digiconomist \cite{BTCenergy} the Bitcoin network annually uses an estimated 49.39 TeraWatt hours of electricity this is roughly equivalent to the usage of Singapore. Beyond this it relies on the assumption the majority of computational power will represent an honest group of parties, this is commonly referred to as a 51\% attack\cite{BTCWhitepaper}\cite{baliga2017understanding}. In smaller blockchains this isn't as reliable as it is easier for a larger party to make up a majority. 

Other consensus schemes rely on being able to trust the validators to be honest, two such methods are proof of stake and proof of authority\cite{blockchainBeginners}\cite{baliga2017understanding}: where a party shows that they will take a loss if they are dishonest thus allowing them to participate in the consensus. In proof of authority a party has control over the blockchain for example in a permissioned blockchain where validators must sign the blockchain with a private key belonging to the owner to make the block valid. These solutions do mitigate the problems of proof of work but require trust in the authority or the magnitude of the stake being a worthy incentive.

\subsubsection{Smart Contracts}
Smart contracts enable users to execute code on the blockchain, some blockchains use smart contracts as an important feature of its services such as Ethereum \cite{wood2014ethereum} and Hyperledger Burrow \cite{HyperLedgerBurrow} where users can execute arbitrary code. When designing a blockchain for E-Voting we can add specific smart contracts for that purpose. The ability to execute code on a blockchain can allow a wide array of E-Voting algorithms to be ran on the blockchain itself. Though some E-Voting algorithms do exist without smart contract capabilities such as the protocol designed by Zhou and Chan for voting using Bitcoin \cite{zhao2015vote}. But protocols such as this are limited by the strict nature of the Bitcoin platform and the inability to perform certain actions available to platforms like Ethereum.

Code executed on a blockchain is stored in a special smart contract layer as a transaction. Where it can be executed by validators to add more transactions or executed by parties reading it if the code does not require any state change.

\subsubsection{Ethereum}
%don't like reward
Ethereum is a blockchain specifically designed for smart contracts by Wood in 2014 \cite{wood2014ethereum}. It can run code through transactions which is run by validators of the blockchain. Code difficulty to run is measured in 'gas' which users can set a transaction value which uses the Ethereum cryptocurrency 'ether'. This results in a system where you can pay to run code on a public blockchain effectively hiring the computer resources of the validators to run code as part of the transaction.

%could maybe include more here on gas and ether prices etc 

\subsection{Blind Signatures}
Blind signatures in cryptography as described by Chaum \cite{chaum1983blind}, are methods of providing a cryptographic signature to a client without the server or authority learning the content they have signed. This can be used to help protect the privacy of an individual. This can be achieved with RSA keys with the following algorithm \cite{MITcrypto}.
\(m, s, r, e, d, N\) These characters represent the message, signed message, random coprime of N, public RSA exponent, private RSA exponent, and RSA modulus N.
\begin{itemize}
    \item client sends blinded message using random blinding factor and public key: \\
    \(m_b = m.r^e (mod N)\)
    \item authority signs the blinded message using private key: \\
    \(s_b = m^d_b = m^d.r^ed = m^d.r (mod N)\)
    \item client unblinds the signed message using the modular inverse of \(r, r^{-1}\): \\
    \(s = s^e_b.r^{-1} = m^d.r.r^{-1} = m^d (mod N)\)
\end{itemize}

\subsection{Technologies for Implementation}
%subsection name work in progress
In this section we look at different languages and technologies to use for implementing a distributed application. Choosing which are preferable for our system.


\subsubsection{Solidity}
Solidity is a language designed specifically for use on the Ethereum blockchain, because of this it has strict rules that help develop more concise more efficient code for blockchains to help reduce transaction costs. One disadvantage of Solidity though is how quickly the language changes due to it being in early development with the release of version 0.5.x in 2019 it broke a lot of pre-existing code due to big changes in syntax rules and functions being removed from the language.

\subsubsection{Node.js and JavaScript}
Providing a way of running the back-end of the server using JavaScript. Key benefits of using Node is how easy it is to make applications portable which is an issue when having to build a tool using several different platforms. With the node package manager, npm, you can easily install many libraries and track which ones are necessary for your application. The wide selection of libraries include those specifically made for blockchain applications such as Web3 and Truffle.
JavaScript is also the most universal language for client side scripting which makes it an obvious choice for use. JavaScript also has built-in Asynchronous calls ideal for blockchain calls using libraries such as web3 or the truffle frameworks own JavaScript libraries. 

\subsection{Truffle Framework}
An implementation of a Solidity compiler for Ethereum. Available on Node.js, it takes advantage of prior two technologies described whilst building on them for more coherent understandable code. Truffle \cite{truffle} is a framework that covers both the deployment of solidity to a blockchain and communicating with the blockchain using its own web3 libraries with JavaScript. The advantages of Truffle is that it is designed specifically to work across both the blockchain and web implementation of a smart contract, and it's system for smart contract monitoring and deployment makes it much more efficient to use. It does still share the disadvantage of solidity though that being in early development causing potentially application breaking updates.

%This was an obvious choice for me as it included a lot of the packages and tools I needed together and ready working with decent documentation but need to show also why this was greater than the alternatives
\subsection{Java}
%https://github.com/ethereum/ethereumj
The EthereumJ project is an implementation of the Ethereum yellow paper of java. It is fully compatible with maven to deploy the project as a web application. Advantages of using this system are the ability to utilize the many libraries in java which all work perfectly cross platform due to the Java Virtual Machine and the support available for this language due to its popularity. The difficulty of this is that this would also require considerable amounts of a client side scripting language such as JavaScript too to implement parts of the protocol with more sensitive content, which would undermine the reason of using EthereumJ if you need to resort to another platform. 

\subsubsection{Others}
\begin{itemize}
    \item Python is an object oriented language with wide applications due to its selection of available libraries. There is a lot of Support for Python based Ethereum smart contracts such as web3.py and py-evm but many of these projects are still in early development with many reported bugs making it sub-optimal for a stable code development.
    \item PHP is a commonly used language for server side scripting in web development. Though originally designed for web development, due to a lack of asynchronous support it makes the development of blockchain applications using PHP difficult.
\end{itemize}

\subsubsection{Conclusion}
For the smart contract we used the Truffle framework this was preferable for the built-in support for its own testRPC Ganache allowing for faster development. Beyond this it includes its own javascript libraries based off Web3.0 for interacting with contracts, making it much easier to develop a web application for our smart contract. Truffle also includes tools for unit testing smart contracts which isolate functions between different tests which can be useful to prevent false negatives when testing.


%\pagebreak
\section{Design} \label{sec: Design}
%can split this into design and implementation.
In this section we describe the protocol and application for this project, we will also discuss security details for both the smart contract and web application and how these will affect our design. This design involves two key parts the deployment of a smart contract and of a web application to organise the election and interact with the smart contract.

\subsection{High-level Protocol} 
This protocol uses an Ethereum blockchain to allow for public verifiability and blind signatures to protect the privacy of its voters from the election authority as well as ensure voter eligibility as described by Hardwick et. al. \cite{hardwick2018}. The protocol is described here in three phases
%As stated we are using ideas described by Hardwick et. al. \cite{hardwick2018} in our implementation, to summarise our version of their protocol briefly we have split it into 4 phases:
\begin{enumerate}
    \item \textbf{Initialisation Phase}. During this phase a new contract is initialised by the election authority. The authority adds the list of candidates as well as a start and end time. Importantly the authority includes the public key of the authorities RSA key pair. Which allows verification of signed tokens.
    \item \textbf{Authorisation Phase}. At this point voters can begin to authenticate with the authority and get signed tokens. This can be done using the web application through a blind signature scheme, the blinded message is constructed client side and sent to be signed on the server then returned.
    \item \textbf{Voting and Counting Phase}. Everyone with a valid signed token can vote at this point. To do this they construct a ballot and broadcast it to the blockchain. Ballots can be cast between the allotted times as dictated at creation. Votes can be counted at any point after the start time.
\end{enumerate}

\subsection{Interfacing between components}
There are three factors that need to communicate in this application: the client, the server (web application), and blockchain (smart contract). In figure \ref{fig:communication}, we have shown the proposed communications between these factors. We see the initialisation, authorisation, voting and counting protocols. This diagram demonstrates that the server at no point directly contacts the blockchain. All smart contract calls are done from the client side using JavaScript.

Although the server initialises each section in the diagram, the client would typically send a request first which has been excluded from diagram for brevity. 

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.3]{ss_communication.png}
    \caption{Interactions that must take place between services}
    \label{fig:communication}
\end{figure}

\subsection{Security design and recommendations} \label{sec: security design}
%this could be split into parts 
In this section we briefly consider some potential security flaws that could undermine the project and discuss efforts made or what could be done to mitigate them with a risk analysis. We will use the STRIDE model \cite{STRIDE} for defining attacks on the system and a risk model comparing likelihood and impact on a scale of one to five.

\subsubsection{Voter privacy}
One intention of this project was to demonstrate that privacy can be assured on a blockchain where many can read the information, this privacy is meaningless unless efforts of made to protect the voter's privacy across the entire voting procedure. 
\textbf{Attack} - Theft of user data or ballot through ip/packet sniffing \cite{ansari2002packet} combined with blockchain analysis. By inspecting the packets or ip addresses sent to the web application you could discover user data and even make educated guesses on the ip of a voter by comparing when ballots are submitted to when voting requests are made. \\
\textbf{Threat} - Spoofing, and Information Disclosure. \\
\textbf{Risk} - Likelihood is reasonable 3/5, it requires technical proficiency but is hard to detect. Impact is high 4/5 depending on how much information is leaked but it could undermine the entire purpose of this application.\\
\textbf{Design choices and solutions}
\begin{itemize}
    \item HTTPS, this is an easy solution to packet sniffing and should be implemented when deploying the web application.
    \item Permissioned blockchain, this is a potential method of reducing who could compare the blockchain data to ip calls. But this is a poor solution as it only prevent those without read permissions from performing this attack, those with permission who are likely to be the ones with the most interest in discovering this information can still perform the attack.
    \item Use of a virtual private network or tor network, this will protect from identification on the server side and client side. There are ways of circumventing these defences but they act as another protective layer from attacks.
\end{itemize}

\subsubsection{SQL Injection}
\textbf{Attack} - SQL Injection when authorising users, this could lead to unlimited tokens being available and querying the database for private information of voters. \\
\textbf{Threat} - Elevation of privileges, and potential Information Disclosure \\
\textbf{Risk} - Likelihood is high 4/5, SQL Injection is commonly known exploit. Impact is high 4/5, this could break the election and be a violation of laws protecting individuals data such as the GDPR \cite{GDPR}.\\
\textbf{Design choices and solutions}
\begin{itemize}
    \item sanitize SQL inputs, the Node.js SQL library has functions that will escape all special character when querying the database. These are used to ensure security against Injection.
\end{itemize}

\subsubsection{Spoofing attacks and Denial of Service when authenticating}
\textbf{Attack} -  By stealing identifying information or by preventing responses from the web application, an attack could steal or deny an individual their vote. \\
\textbf{Threat} - Spoofing or Denial of Service\\
\textbf{Risk} - Likelihood is medium 3/5 this attack description is broad purposefully because these attacks all have a similar result, . Impact is high 4/5\\
\textbf{Design choices and solutions}\\
\begin{itemize}
    \item This attack is dependant on the verification method used to get a token, which as we will discuss in the implementation, section \ref{sec: implementation}, is dependant entirely on where this application is being used but the impact of this attack would remove the ability to vote. There is no way to prove to the authority that your vote has been stolen or not received, when utilising this application then authorities should use a strong method of authentication such as a unique high entropy password backed up with multi-factor authentication. Using a service like Authy \cite{Authy} for example, an app that requires a one time password sent to your mobile device.
    \item Another defence against this attack is anonymous access, by accessing the web application through a virtual private network or the tor network you can make it harder to tell who the voter is. Without this information denial of service attacks become randomised reducing the benefit that an individual would get from performing the attack.
\end{itemize}

\subsubsection{Authority Attack} \label{sec: Authority Attack}
\textbf{Attack} - The authority has control over the private key used to sign voters tokens, but this means the authority could create their own tokens and vote without detection. \\
\textbf{Threat} - Spoofing \\
\textbf{Risk} - Likelihood is low 2/5 it is difficult to measure the likelihood and depends on trust in an authority, it is though a severe threat the impact is extremely high 5/5.\\
\textbf{Design choices and solutions}
\begin{itemize}
    \item Reduce anonymity, one potential way to combat this attack would be for the authority to release a list of individuals that requested a token. If this number is greater than the ballots cast then it would be evident that the authority cheated, but this isn't an absolute solution as there would still need to be some way to confirm the list is legitimate.
    \item This attack ultimately did not result in any design choices being made, but it warrants discussion as it is a security risk in this application.
\end{itemize}


\section{Implementation} \label{sec: implementation}

\subsection{Creating an Election}
%find out if you can include an appendix

%NOTE remember if I get time I want to dynamically create the rsa keys for each election rather than using a pre-generated one this is more secure and a constructor param would be the modulus  so this paragraph here would have to change.
To create an election the party must initialise the smart contract creating a new instance on the Ethereum blockchain. When initialising the contract, there are two inputs: the start time, and end time. These parameters are used to dictate when certain functions are allowed to be called by comparing it to the current block's timestamp. These parameters are all stored in this instance of the smart contract. The contract also stores the public key of the RSA key pair, for this implementation we used a constant key pair but the contract could also take the public key as a parameter, we used a static one to reduce transaction cost.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_constructor.png}
    \caption{Constructor prototype}
    \label{fig:constructor}
\end{figure}


One issue encountered when designing this stage of the protocol is that solidity doesn't yet support nested arrays, so you cannot pass the candidates list as a parameter, as can be seen from the prototype in figure \ref{fig:constructor}. This was easily circumvented by creating an add candidate function, see figure \ref{fig:addCand}. This also adds more flexibility to the smart contract allowing to add potentially late-entering candidates after the contract is instantiated. 

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_addCand.png}
    \caption{Add candidate prototype}
    \label{fig:addCand}
\end{figure}

The web application interfaces with the smart contract on the create page where we allow for the creation of a new instance or to look up an existing instance using the contract memory address. When created or by looking a contract up you can view current candidates list and call the add candidates function providing you meet the requirements of calling it. Those being that the function is called by the instance creator, and that it is called before the start-time.

After creating the contract the web application also displays the instance address as can be seen in figure \ref{fig:create_loaded}, this is important for none technical users that might not know how to extract this information from transaction history and are relying on the web application. The instance creator can then distribute this address to the voters.

%might want to reduce this to scale 0.5?
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_create_loaded.png}
    \caption{Web application viewing loaded contract on create page}
    \label{fig:create_loaded}
\end{figure}

%when talking about signing hardwick et al say they use the blockchain public key I didnt do that due to the signing issue of sending an arbitrary message to be signed by the CA that they cannot detect due to it being blinded this is circumvented by using RSA

\subsection{Authorisation}\label{sec: Auth}
This phase involves the process of authenticating to the authority running the vote. This process is solely done in the web application. This is to protect the identity of the voters, the authority needs to use a centralised database or some equivalent private form of data storage. For our implementation we used an SQL database where the voter could authenticate using a username and password, though the process of authentication is application dependant. The factor most important in this phase is the use of blind signatures to produce a signed message or 'token' that the voter can use to prove they are authorised to vote without revealing their identity to anyone when they vote including the authority who only knows the voter has a valid token not which voter has which token. The message we used was the voter's Ethereum address as this could be verified on the blockchain by looking at the transaction origin.

When validating the signature all the smart contract needs to check is the message, the sender's address should be equivalent to the message.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.45]{ss_verifyToken.png}
    \caption{Verify token prototype}
    \label{fig:verifyToken}
\end{figure}

The security of this method of assuring total privacy has caveats though, it is only a strong method if there is no way to circumvent the system. This could be either through recognising the address of the voter or through monitoring packets and ip addresses sent to the website. We must also assure then that appropriate steps are taken.
This method should still assure eligibility though even if privacy and anonymity are compromised due to external factors.

\subsection{voting and counting} \label{sec: voting and counting}
Voting is done on the web application by loading the correct memory address for the desired contract instance, in a real-world application this would be given when told about the vote. After loading the contract the voter must select a candidate and provide a valid token as seen in figure \ref{fig:vote_loaded}, using JavaScript this is then sent as a contract call. As can be seen in figure \ref{fig:castBallot} the castBallot function takes these inputs and constructs a ballot to be appended to the ballot list. The token is verified as discussed in section \ref{sec: Auth}. 
Beyond assuring authorisation voting should also be limited to a period of time so a final result can be decided upon, for this we can require that voting only occurs within the predefined period of the start of the election and the end of the election.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_castBallot.png}
    \caption{Verify token prototype}
    \label{fig:castBallot}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_voteLoaded.png}
    \caption{Web application viewing loaded contract on the vote page}
    \label{fig:vote_loaded}
\end{figure}

Finally the smart contract provides a function to count the votes figure \ref{fig:count} for each candidate, this is achievable without using a function but this allows for easier access. The web application interfaces with this function on the results page where you can load and view the results of any contract by the contract instance address.

%could also here show that ballots are public allowing the function get ballots(address)

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{ss_count.png}
    \caption{Count prototype}
    \label{fig:count}
\end{figure}

\pagebreak
\section{Testing and Evaluation}

\subsection{Cost} \label{sec: cost}
Ethereum smart contract transactions that change the state of the blockchain have an associated cost to them, measured in gas. This is a measurement of how difficult it is to run these transactions for the validators, if this smart contract was to be ran on a public Ethereum blockchain this would also be a measure of monetary cost. 

There are three functions that change the state of the blockchain, which can be seen in the table below.

\begin{table}[h!]
\centering
\begin{tabular}{|c c c|}
 \hline
 Operation & Gas & Ether* \\ 
 \hline
 Contract Creation & 1535752 & 0.01911 \\  
 Add Candidate & 54534 & 0.00068 \\  
 Cast Ballot & 362590 & 0.00451 \\  
 \hline
\end{tabular}
\end{table}

For gas price into ether we used the average gas price on the main Ethereum network (ETC) over a period of 60 days, this worked out at an average of \(12,442,000,000\) Wei or \(1.2442 \times 10^{-8}\) Ether. This value is used as a good approximation but in reality ETC prices and gas price are extremely volatile. These values were gathered on Etherscan \cite{gasprice} and a collection of the calculations can be found in the supplementary material. Another variable that affects these results is the state being written, candidate name is the only variable of unknown size for which we used a length of 10 characters.

These results highlight a potential limitation for this application, high costs. At the time of writing ETC on the Ethereum public network is valued at £182 to 1ETC, this monetary cost becomes an issue when voting in large numbers. For example to set up an election with 10 candidates it will cost approximately 0.02591 ether or £1.25 using the conversion value above, but then per vote cast it costs an additional 82p. This will likely prevent this application being used on a public blockchain where Ethereum must be purchased as either the voter or the authority would have to pay to cast ballots. The cost to vote is high due to vote validation. When removing token validation the gas used dropped to 322,978 a decrease of over 40,000. This shows the expense of validation in this operation.

\subsection{Unit Testing}
Tests for the smart contract were written using Mocha \cite{mocha}. Mocha runs tests serially with an assert style testing mechanism, for which we are using Chai \cite{chai}. Below

These tests help show that the smart contract is behaving as expected, you can see the output for these tests in figure \ref{fig:testResults}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.8]{ss_testResults.png}
    \caption{Test output}
    \label{fig:testResults}
\end{figure}


%show the gas pricing of each transaction
%discuss the unit tests performed on the smart contracts
%maybe latency would be a good idea


\subsection{Evaluation of Voting Properties}\label{sec: Eval}

\begin{itemize}
    \item Privacy, Eligibility, Unreusability and Anonymity, using RSA signatures and providing the voter protects their identity when connecting to the server we have shown that the voter's privacy and anonymity are protected. Then by having the process of authentication and token verification we ensure Eligibility and Unreusability. 
    \item Verifiability. We can show that this is possible by looking at transaction history on the blockchain. This hasn't been hindered by adding Privacy and Anonymity, and as seen in section \ref{sec: voting and counting} public verifiability and E2E verifiability are in-built.
    \item Fairness. Fairness was not achieved, initially we wished to include voter fairness where a voter cannot read votes before the end of the election unfortunately partially due to time constraints and partially due to the increased complexity this would have added this was not achieved. One method of achieving voter fairness could of been to encrypt votes when casting a ballot and then decrypt them after the election but this would have required effectively a second voting phase to decrypt making the protocol less usable.
    \item Usability and Availability. One key issue is that with a blind signature scheme you can not prove the existence of a used token or lost/stolen token by consequence. Therefor if a voter loses their token that voter will not be able to participate in that election. This system does offer benefits on usability though over a conventional paper system, such as the ability to participate completely over the internet. With this system a voter could also register and vote within the same day. Another difficulty of using a blockchain for E-Voting is that it requires technical knowledge to use. This was the purpose of using a web application which has helped with interfacing with the smart contract but there are still technical details that a none-technical user could likely struggle with, such as using contract address.
    \item Transparency. Improved transparency comes from the decentralised nature of this application, the entire application can be safely hosted on public blockchains where almost all of the functionality is visible to the users. The only operation that is hidden by design is the server side blind signature scheme which must be hidden to protect the private key.
    \item Robustness and Security. In section \ref{sec: security design} we discussed security issues that we should consider for our implementation or that should be considered when deciding whether this application is suitable for a particular use case. We noted security flaws such as the authority attack in section \ref{sec: Authority Attack} which demonstrates this application is vulnerable to a malicious authority, given that elections are a way of an electorate expressing their wishes it is important for the electorate to realise that this application does guarantee the authority must be honest just that dishonesty is more visible.
\end{itemize}


\section{Conclusions and further work}
During this project we have demonstrated a great deal about design choices, it is incredibly hard to include all the features you wish to without sacrificing the functionality already achieved. It is important to achieve primary goals first then evaluate potential additions. Beyond this we have shown the immense potential of blockchain technology, showing that it can be applied to problems outside of its original use to improve transparency and verifiability.

Uses for this application will likely be limited to small to medium scale distributed elections. The difficulties posed by this protocol as discussed in section \ref{sec:eval} and section \ref{sec: cost} make it unforgiving to voters that make mistakes in the protocol and expensive leaving it unsuitable for large scale elections. Alternatives do exist to circumvent this having signed tokens assigned for each voter but this would forgo the privacy granted by blind signing.

In the future I would like to try add voter fairness, looking at alternative ways to provide this without drastically decreasing usability. Another improvement I think could be made is trying to integrate Elliptic curve cryptography (ECC) instead of RSA, many blockchains are built using ECC, for address and signing. Ethereum uses the Elliptic Curve Digital Signature Algorithm (ECDSA) because of the reduced key sizes required for the algorithm. This would be an interesting area for further investigation, built-in support and smaller keys could make for cheaper transaction costs as seen in section \ref{sec: cost} and more manageable key sizes for users.

This method of E-Voting demonstrates interesting solutions to problems posed by public voting. It is impossible to say whether this is preferable to existing physical or digital system, but it is different and serves to provide a valid alternative. 

\printbibliography

\end{document}
